syntax = "proto3";

package chunk_dictionary;

message ChunkCompression
{
    enum CompressionType {
        NONE = 0;
        LZMA = 1;
        ZSTD = 2;
    }
    CompressionType compression = 2;
    uint32 compression_level = 3;
}

message ChunkStore
{
    enum StoreType {
        // Chunk is stored in separate file
        CHUNK_FILE = 0;
        // Chunks are inside an archive
        ARCHIVE = 1;
    }
    StoreType store_type = 1;

    // When type is CHUNK_FILE then this path probably refers to a relative directory.
    // When type is ARCHIVE then it refers to a file. 
    string store_path = 2;
}

message ChunkDescriptor
{
    // Hash of uncompressed chunk
    bytes checksum = 1;

    // Size of uncompressed chunk data
    uint64 size = 2;

    // Archive chunk data compression type and level
    ChunkCompression compression = 3;

    // Size of chunk data when compressed
    uint64 compressed_size = 4;

    // Chunk data byte offset inside store
    uint64 archive_offset = 5;

    // Refers to an entry in the location vector of dictionary
    uint32 location_index = 6;
}

message ChunkerParameters
{
    uint32 chunk_filter_bits = 1;
    uint64 min_chunk_size = 2;
    uint64 max_chunk_size = 3;
    uint32 hash_window_size = 4;
    uint32 chunk_hash_length = 5;
}

message ChunkDictionary
{
    // Dictionary was created with this version
    string application_version = 1;

    // Hash of the source file
    bytes source_checksum = 2;

    // Total size of the source file
    uint64 source_total_size = 3;

    // Describes where chunk data stored.
    // Each chunk descriptor refers to an entry in this list.
    repeated ChunkStore chunk_stores = 4;
    
    // Chunker parameters used when building archive
    ChunkerParameters chunker_params = 5;

    // Array of chunk descriptor indexes describing howto rebuild the source
    repeated uint32 rebuild_order = 6;

    // Chunk descriptors in order of first occurence in source file
    repeated ChunkDescriptor chunk_descriptors = 7;
}
